#!/usr/bin/env bpftrace

// NOTE: could only obtain read and write latency numbers for the SCSI layer (while on the RBD layer I could get also flush and discard).
// - Reason: could not find good points in the QEMU source code to use to map a request to a completion callback.
// - for read and write, they are mapped to DMA operations that have a clear entrypoint with the scsi_write_data and scsi_read_data functions and each call
//   can be uniquely identified by the pointer to the SCSIRequest struct.

// NOTE: you can get SCSI-level read/write/flush/discard latencies using QMP via e.g
// - activate tracepoints and calculate histograms: sudo virsh qemu-monitor-command <guest-id> block-latency-histogram-set '{"id":"ua-ceph-<ceph_id>","boundaries":[1000000, 2000000, 4000000, 8000000, 16000000, 32000000, 64000000, 128000000, 256000000, 512000000, 1024000000]}'
// - and then sudo virsh qemu-monitor-command <guest-id> query-blockstats | jq '.return[] | { qdev: .qdev, rd: .stats.rd_latency_histogram, wr: .stats.wr_latency_histogram, flush: .stats.flush_latency_histogram } | { qdev, rd: ([.rd.boundaries, .rd.bins] | transpose), wr: ([.wr.boundaries, .wr.bins] | transpose), flush: ([.flush.boundaries, .flush.bins] | transpose) }'
// ---> I have done a comparison between the histogram calculated via QEMU internal tracepoints and this bpftrace code and found they match well.

// bpftrace struct support: https://bpftrace.org/docs/release_023/language#structs
#define BDRV_SECTOR_SIZE 512

enum SCSIXferMode {
    SCSI_XFER_NONE,      /*  TEST_UNIT_READY, ...            */
    SCSI_XFER_FROM_DEV,  /*  READ, INQUIRY, MODE_SENSE, ...  */
    SCSI_XFER_TO_DEV,    /*  WRITE, MODE_SELECT, ...         */
};

struct SCSICommand {
    uint8_t buf[16];
    int len;
    size_t xfer;
    uint64_t lba;
    enum SCSIXferMode mode;
}

struct SCSIRequest {
    void                *bus;
    void                *dev;
    const          void *ops;
    void                *ctx;
    uint32_t            refcount;
    uint32_t            tag;
    uint32_t            lun;
    int16_t             status;
    int16_t             host_status;
    void                *hba_private;
    uint64_t            residual;
    struct SCSICommand  cmd;
};

struct QEMUIOVector {};
struct BlockAcctCookie {};

struct SCSIDiskReq {
    struct SCSIRequest req;
    uint64_t sector;
    uint32_t sector_count;
    uint32_t buflen;
    bool started;
    bool need_fua;
    struct iovec iov;
    struct QEMUIOVector qiov;
    struct BlockAcctCookie acct;
};

// from: https://github.com/qemu/qemu/blob/master/hw/scsi/scsi-disk.c#L1854C9-L1860C2
struct WriteSameCBData {
    // we only care about the memory address here to match the request in the scsi_write_same_complete to the scsi_disk_emulate_write_same
    struct SCSIDiskReq *r;
    int64_t sector;
    int nb_sectors;
    struct QEMUIOVector qiov;
    struct iovec iov;
};


BEGIN
{
  printf("Tracing SCSI write operations in QEMU...\n");
}

// `scsi_write_data` is called for writing DMA requests which includes WRITE_10,... (but excludes WRITE_SAME, SYNCHRONIZE, ...)
// having a hard time to get the actual command from the buffer. Doesn't matter, I can directly see the
// corresponding block requests when looking in the block layer
uprobe:/usr/bin/qemu-system-x86_64:scsi_write_data.lto_priv.0
{
  $scsi_request_ptr = (struct SCSIRequest *) arg0;

  @start_write[$scsi_request_ptr] = nsecs;
  printf("WRITE: scsi_write_data.lto_priv.0 | time: %-8ld | ptr: %p \n", nsecs / 1000000, $scsi_request_ptr);
}

uprobe:/usr/bin/qemu-system-x86_64:scsi_read_data.lto_priv.0
{
  $scsi_request_ptr = (struct SCSIRequest *) arg0;

  @start_read[$scsi_request_ptr] = nsecs;
  printf("READ: scsi_read_data.lto_priv.0 | time: %-8ld | ptr: %p  \n", nsecs / 1000000, $scsi_request_ptr);
}

uprobe:/usr/bin/qemu-system-x86_64:scsi_write_data.lto_priv.1
{
  $scsi_request_ptr = (struct SCSIRequest *) arg0;

  @start_write[$scsi_request_ptr] = nsecs;
  printf("WRITE: scsi_write_data.lto_priv.1 | time: %-8ld \n", nsecs / 1000000);
}

// called from `scsi_write_data`: https://github.com/qemu/qemu/blob/master/hw/scsi/scsi-disk.c#L640
uprobe:/usr/bin/qemu-system-x86_64:scsi_dma_complete_noio
{
  $scsi_request_ptr = (struct SCSIRequest *) arg0;

  // I can get the size of the request in the block layer, but that's not necessary for my latency measurements
  // $scsi_disk_request = (struct SCSIDiskReq *) arg0;
  // based on calculations in scsi_disk_dma_command https://github.com/qemu/qemu/blob/master/hw/scsi/scsi-disk.c#L2376
  // TOOD: likely sometimes the structs filed sector size is simply not set, hence has random values in it (but once we get 4096)!
  // $scsi_request_size = $scsi_disk_request->sector_count * BDRV_SECTOR_SIZE;
  // $buf_hex_dump = buf($scsi_request_ptr->cmd.buf, 1);

  if (@start_write[$scsi_request_ptr] != 0) {
    $delta_ns = nsecs - @start_write[$scsi_request_ptr];

    // Convert nanoseconds to milliseconds for the histogram
    $delta_ms = $delta_ns / 1000000;

    // Add the latency to the histogram
    @write_latency_ms = hist($delta_ms);

    // Add to the average calculation
    @write_latency_ms_avg = avg($delta_ms);

    delete(@start_write[$scsi_request_ptr]);
    printf("%-8ld | %-16s | PID: %-6d | TID: %d | ptr: %p | took %lld ms (scsi_dma_complete_noio) \n", nsecs / 1000000, comm, pid, tid, $scsi_request_ptr , $delta_ms);
  } else if (@start_read[$scsi_request_ptr] != 0) {
    $delta_ns = nsecs - @start_read[$scsi_request_ptr];
    // Convert nanoseconds to milliseconds for the histogram
    $delta_ms = $delta_ns / 1000000;

    // Add the latency to the histogram
    @read_latency_ms = hist($delta_ms);

    // Add to the average calculation
    @read_latency_ms_avg = avg($delta_ms);


    delete(@start_read[$scsi_request_ptr]);
    printf("%-8ld | %-16s | PID: %-6d | TID: %d | ptr: %p | took %lld ms (scsi_dma_complete_noio) \n", nsecs / 1000000, comm, pid, tid, $scsi_request_ptr , $delta_ms);
  } else {
    printf("%-16s | PID: %-6d | TID: %-10d | WARNING: scsi_dma_complete_noio fired, but start time for %p not found! \n",
           comm, pid, tid, $scsi_request_ptr);
  }
}

// TODO: below 2 functions are somehow not called, but I left them in here in case trim & flush support is to be investigated later
// only called for non-DMA write operations (SYNC, TRIM, ...)
uprobe:/usr/bin/qemu-system-x86_64:scsi_write_complete_noio
{
  $scsi_request_ptr = (struct SCSIRequest *) arg0;
  if (@start_write[$scsi_request_ptr] != 0) {
    $delta = nsecs - @start_write[$scsi_request_ptr];
    delete(@start_write[$scsi_request_ptr]);
    printf("%-8ld | %-16s | PID: %-6d | TID: %d | took %lld nanoseconds (scsi_write_complete_noio) \n", nsecs / 1000000, comm, pid, tid, $delta);
  } else {
    printf("%-16s | PID: %-6d | TID: %-10d | WARNING: scsi_write_complete_noio fired, but start time for %p not found! \n",
           comm, pid, tid, $scsi_request_ptr);
  }
}

// only called for non-DMA read operations (because there is a transfer direction for DMA requests)
// - regular READ_10,.. are a DMA operation, hence won't be in here!
uprobe:/usr/bin/qemu-system-x86_64:scsi_read_complete_noio
{
  $scsi_request_ptr = (struct SCSIRequest *) arg0;

  if (@start_read[$scsi_request_ptr] != 0) {
    $delta = nsecs - @start_read[$scsi_request_ptr];
    delete(@start_read[$scsi_request_ptr]);
    printf("%-8ld | %-16s | PID: %-6d | TID: %d | ptr: %p | took %lld nanoseconds (scsi_read_complete_noio) \n", nsecs / 1000000, comm, pid, tid, $scsi_request_ptr , $delta);
  } else {
    printf("%-16s | PID: %-6d | TID: %-10d | WARNING: scsi_read_complete_noio fired, but start time for %p not found! \n",
           comm, pid, tid, $scsi_request_ptr);
  }
}

END
{
    printf("\n--------------------------------------------------------------------------------\n");
    printf("Script ended. Checking for uncompleted SCSI operations...\n");
    // Iterate over the @start map to find any entries that were not deleted
    // (i.e., start events without a corresponding completion event)
    printf("The following pointers had a start event but no corresponding completion:\n");
    print(@start_write); // Print the map contents (TID: start_nsecs)
}